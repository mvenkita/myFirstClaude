<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CBOR MDL Decoder</title>
    <script>
        // Lightweight CBOR decoder implementation
        class CBORDecoder {
            constructor(buffer) {
                this.buffer = new Uint8Array(buffer);
                this.offset = 0;
            }

            decode() {
                return this.decodeValue();
            }

            decodeValue() {
                if (this.offset >= this.buffer.length) {
                    throw new Error('Unexpected end of CBOR data');
                }

                const initialByte = this.buffer[this.offset++];
                const majorType = (initialByte >> 5) & 0x07;
                const additionalInfo = initialByte & 0x1f;

                switch (majorType) {
                    case 0: // Unsigned integer
                        return this.decodeInteger(additionalInfo);
                    case 1: // Negative integer
                        return -1 - this.decodeInteger(additionalInfo);
                    case 2: // Byte string
                        return this.decodeByteString(additionalInfo);
                    case 3: // Text string
                        return this.decodeTextString(additionalInfo);
                    case 4: // Array
                        return this.decodeArray(additionalInfo);
                    case 5: // Map
                        return this.decodeMap(additionalInfo);
                    case 6: // Semantic tag
                        const tag = this.decodeInteger(additionalInfo);
                        const value = this.decodeValue();
                        return { __cbor_tag: tag, value: value };
                    case 7: // Floating-point numbers and simple values
                        return this.decodeSpecial(additionalInfo);
                    default:
                        throw new Error(`Unknown CBOR major type: ${majorType}`);
                }
            }

            decodeInteger(additionalInfo) {
                if (additionalInfo < 24) {
                    return additionalInfo;
                } else if (additionalInfo === 24) {
                    return this.buffer[this.offset++];
                } else if (additionalInfo === 25) {
                    const value = (this.buffer[this.offset] << 8) | this.buffer[this.offset + 1];
                    this.offset += 2;
                    return value;
                } else if (additionalInfo === 26) {
                    const value = (this.buffer[this.offset] << 24) | 
                                 (this.buffer[this.offset + 1] << 16) | 
                                 (this.buffer[this.offset + 2] << 8) | 
                                 this.buffer[this.offset + 3];
                    this.offset += 4;
                    return value >>> 0; // Unsigned
                } else if (additionalInfo === 27) {
                    // 64-bit integer (simplified - may lose precision for very large numbers)
                    const high = (this.buffer[this.offset] << 24) | 
                                (this.buffer[this.offset + 1] << 16) | 
                                (this.buffer[this.offset + 2] << 8) | 
                                this.buffer[this.offset + 3];
                    const low = (this.buffer[this.offset + 4] << 24) | 
                               (this.buffer[this.offset + 5] << 16) | 
                               (this.buffer[this.offset + 6] << 8) | 
                               this.buffer[this.offset + 7];
                    this.offset += 8;
                    return (high * 0x100000000) + (low >>> 0);
                } else {
                    throw new Error(`Invalid additional info for integer: ${additionalInfo}`);
                }
            }

            decodeByteString(additionalInfo) {
                const length = this.decodeInteger(additionalInfo);
                const bytes = this.buffer.slice(this.offset, this.offset + length);
                this.offset += length;
                return bytes;
            }

            decodeTextString(additionalInfo) {
                const bytes = this.decodeByteString(additionalInfo);
                return new TextDecoder('utf-8').decode(bytes);
            }

            decodeArray(additionalInfo) {
                const length = this.decodeInteger(additionalInfo);
                const array = [];
                for (let i = 0; i < length; i++) {
                    array.push(this.decodeValue());
                }
                return array;
            }

            decodeMap(additionalInfo) {
                const length = this.decodeInteger(additionalInfo);
                const map = {};
                for (let i = 0; i < length; i++) {
                    const key = this.decodeValue();
                    const value = this.decodeValue();
                    // Convert key to string if it's not already
                    const keyStr = typeof key === 'string' ? key : String(key);
                    map[keyStr] = value;
                }
                return map;
            }

            decodeSpecial(additionalInfo) {
                if (additionalInfo < 20) {
                    return additionalInfo;
                } else if (additionalInfo === 20) {
                    return false;
                } else if (additionalInfo === 21) {
                    return true;
                } else if (additionalInfo === 22) {
                    return null;
                } else if (additionalInfo === 23) {
                    return undefined;
                } else if (additionalInfo === 25) {
                    // Half-precision float (simplified)
                    const value = (this.buffer[this.offset] << 8) | this.buffer[this.offset + 1];
                    this.offset += 2;
                    return this.decodeHalfFloat(value);
                } else if (additionalInfo === 26) {
                    // Single-precision float
                    const bytes = this.buffer.slice(this.offset, this.offset + 4);
                    this.offset += 4;
                    const view = new DataView(bytes.buffer, bytes.byteOffset, 4);
                    return view.getFloat32(0, false);
                } else if (additionalInfo === 27) {
                    // Double-precision float
                    const bytes = this.buffer.slice(this.offset, this.offset + 8);
                    this.offset += 8;
                    const view = new DataView(bytes.buffer, bytes.byteOffset, 8);
                    return view.getFloat64(0, false);
                } else {
                    throw new Error(`Unknown special value: ${additionalInfo}`);
                }
            }

            decodeHalfFloat(value) {
                const sign = (value & 0x8000) ? -1 : 1;
                const exponent = (value & 0x7c00) >> 10;
                const fraction = value & 0x03ff;

                if (exponent === 0) {
                    return sign * Math.pow(2, -14) * (fraction / Math.pow(2, 10));
                } else if (exponent === 0x1f) {
                    return fraction ? NaN : sign * Infinity;
                } else {
                    return sign * Math.pow(2, exponent - 15) * (1 + fraction / Math.pow(2, 10));
                }
            }
        }

        // CBOR API wrapper
        window.CBOR = {
            decode: function(buffer) {
                const decoder = new CBORDecoder(buffer);
                return decoder.decode();
            }
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 300;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }
        
        .upload-section {
            padding: 40px;
            text-align: center;
            border-bottom: 1px solid #eee;
        }
        
        .file-drop-zone {
            border: 3px dashed #3498db;
            border-radius: 15px;
            padding: 40px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.05), rgba(155, 89, 182, 0.05));
        }
        
        .file-drop-zone:hover, .file-drop-zone.dragover {
            border-color: #2980b9;
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.1), rgba(155, 89, 182, 0.1));
            transform: translateY(-2px);
        }
        
        .file-drop-zone i {
            font-size: 3rem;
            color: #3498db;
            margin-bottom: 15px;
            display: block;
        }
        
        .file-input {
            display: none;
        }
        
        .btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }
        
        .output-section {
            padding: 40px;
            min-height: 400px;
        }
        
        .json-tree {
            font-family: 'Courier New', monospace;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            max-height: 600px;
            overflow-y: auto;
            border: 1px solid #e9ecef;
        }
        
        .tree-node {
            margin: 2px 0;
        }
        
        .tree-key {
            color: #e74c3c;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
        }
        
        .tree-value {
            color: #27ae60;
        }
        
        .tree-string {
            color: #f39c12;
        }
        
        .tree-number {
            color: #3498db;
        }
        
        .tree-boolean {
            color: #9b59b6;
        }
        
        .tree-null {
            color: #95a5a6;
            font-style: italic;
        }
        
        .tree-binary {
            color: #e67e22;
            font-style: italic;
        }
        
        .tree-toggle {
            display: inline-block;
            width: 16px;
            text-align: center;
            cursor: pointer;
            user-select: none;
            color: #7f8c8d;
            font-weight: bold;
        }
        
        .tree-children {
            margin-left: 20px;
            border-left: 1px solid #ecf0f1;
            padding-left: 10px;
        }
        
        .tree-children.collapsed {
            display: none;
        }
        
        .error {
            background: #fee;
            color: #c33;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #fcc;
            margin: 20px 0;
        }
        
        .success {
            background: #efe;
            color: #393;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #cfc;
            margin: 20px 0;
        }
        
        .info {
            background: #e7f3ff;
            color: #0066cc;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #b3d9ff;
            margin: 20px 0;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #ffffff, #f8f9fa);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            border: 1px solid #e9ecef;
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #2c3e50;
        }
        
        .stat-label {
            color: #7f8c8d;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>CBOR MDL Decoder</h1>
            <p>Upload and decode CBOR-encoded Mobile Driver's License files</p>
        </div>
        
        <div class="upload-section">
            <div class="file-drop-zone" id="dropZone">
                <div style="font-size: 3rem; margin-bottom: 15px;">📄</div>
                <h3>Drop your CBOR file here</h3>
                <p>or click to browse files</p>
            </div>
            <input type="file" id="fileInput" class="file-input" accept=".cbor,.bin,*">
            <button class="btn" onclick="document.getElementById('fileInput').click()">
                Choose File
            </button>
        </div>
        
        <div class="output-section" id="outputSection">
            <div class="info">
                <strong>Ready to decode!</strong> Upload a CBOR file to see its decoded contents in a collapsible tree structure.
            </div>
        </div>
    </div>

    <script>
        let globalStats = { totalNodes: 0, binaryFields: 0, recursiveDecodes: 0 };

        function isArrayBuffer(obj) {
            return obj instanceof ArrayBuffer;
        }

        function isUint8Array(obj) {
            return obj instanceof Uint8Array;
        }

        function isBinaryData(value) {
            return isArrayBuffer(value) || isUint8Array(value) || 
                   (value && typeof value === 'object' && value.constructor === ArrayBuffer) ||
                   (value && typeof value === 'object' && value.constructor === Uint8Array);
        }

        function arrayBufferToHex(buffer) {
            const bytes = new Uint8Array(buffer);
            return Array.from(bytes, byte => byte.toString(16).padStart(2, '0')).join(' ');
        }

        function tryRecursiveCborDecode(binaryData) {
            try {
                if (typeof CBOR === 'undefined' || !CBOR.decode) {
                    console.warn('CBOR decoder not available');
                    return null;
                }

                let uint8Array;
                if (isArrayBuffer(binaryData)) {
                    uint8Array = new Uint8Array(binaryData);
                } else if (isUint8Array(binaryData)) {
                    uint8Array = binaryData;
                } else {
                    return null;
                }

                // Try different CBOR decode methods based on library
                let decoded;
                if (typeof CBOR.decode === 'function') {
                    decoded = CBOR.decode(uint8Array.buffer);
                } else if (typeof CBOR.decode === 'function') {
                    decoded = CBOR.decode(uint8Array);
                } else {
                    return null;
                }
                
                globalStats.recursiveDecodes++;
                return decoded;
            } catch (e) {
                console.warn('Recursive CBOR decode failed:', e.message);
                return null;
            }
        }

        function getValueType(value) {
            if (value === null) return 'null';
            if (typeof value === 'boolean') return 'boolean';
            if (typeof value === 'number') return 'number';
            if (typeof value === 'string') return 'string';
            if (isBinaryData(value)) return 'binary';
            if (Array.isArray(value)) return 'array';
            if (typeof value === 'object') return 'object';
            return 'unknown';
        }

        function formatValue(value, type) {
            switch (type) {
                case 'string':
                    return `"${value}"`;
                case 'number':
                case 'boolean':
                    return String(value);
                case 'null':
                    return 'null';
                case 'binary':
                    const hex = isArrayBuffer(value) ? arrayBufferToHex(value) : arrayBufferToHex(value.buffer || value);
                    const preview = hex.length > 32 ? hex.substring(0, 32) + '...' : hex;
                    return `Binary (${isArrayBuffer(value) ? value.byteLength : value.length} bytes): ${preview}`;
                default:
                    return String(value);
            }
        }

        function renderJsonTree(data, path = '', level = 0) {
            globalStats.totalNodes++;
            
            if (data === null || data === undefined) {
                return `<span class="tree-value tree-null">null</span>`;
            }

            const type = getValueType(data);
            
            if (type === 'binary') {
                globalStats.binaryFields++;
                
                const recursiveDecoded = tryRecursiveCborDecode(data);
                if (recursiveDecoded !== null) {
                    const nodeId = `node-${Math.random().toString(36).substr(2, 9)}`;
                    return `
                        <div class="tree-node">
                            <span class="tree-toggle" onclick="toggleNode('${nodeId}')">▼</span>
                            <span class="tree-key">Binary Data (recursively decoded)</span>
                            <div class="tree-children" id="${nodeId}">
                                ${renderJsonTree(recursiveDecoded, path + '.decoded', level + 1)}
                            </div>
                        </div>
                    `;
                } else {
                    return `<span class="tree-value tree-binary">${formatValue(data, type)}</span>`;
                }
            }

            if (type === 'string' || type === 'number' || type === 'boolean') {
                return `<span class="tree-value tree-${type}">${formatValue(data, type)}</span>`;
            }

            if (Array.isArray(data)) {
                if (data.length === 0) {
                    return `<span class="tree-value">[]</span>`;
                }

                const nodeId = `node-${Math.random().toString(36).substr(2, 9)}`;
                const children = data.map((item, index) => {
                    return `
                        <div class="tree-node">
                            <span class="tree-key">[${index}]:</span> ${renderJsonTree(item, `${path}[${index}]`, level + 1)}
                        </div>
                    `;
                }).join('');

                return `
                    <div class="tree-node">
                        <span class="tree-toggle" onclick="toggleNode('${nodeId}')">▼</span>
                        <span class="tree-key">Array (${data.length} items)</span>
                        <div class="tree-children" id="${nodeId}">
                            ${children}
                        </div>
                    </div>
                `;
            }

            if (typeof data === 'object') {
                const keys = Object.keys(data);
                if (keys.length === 0) {
                    return `<span class="tree-value">{}</span>`;
                }

                const nodeId = `node-${Math.random().toString(36).substr(2, 9)}`;
                const children = keys.map(key => {
                    return `
                        <div class="tree-node">
                            <span class="tree-key">"${key}":</span> ${renderJsonTree(data[key], `${path}.${key}`, level + 1)}
                        </div>
                    `;
                }).join('');

                return `
                    <div class="tree-node">
                        <span class="tree-toggle" onclick="toggleNode('${nodeId}')">▼</span>
                        <span class="tree-key">Object (${keys.length} properties)</span>
                        <div class="tree-children" id="${nodeId}">
                            ${children}
                        </div>
                    </div>
                `;
            }

            return `<span class="tree-value">${String(data)}</span>`;
        }

        function toggleNode(nodeId) {
            const node = document.getElementById(nodeId);
            const toggle = node.previousElementSibling;
            
            if (node.classList.contains('collapsed')) {
                node.classList.remove('collapsed');
                toggle.textContent = '▼';
            } else {
                node.classList.add('collapsed');
                toggle.textContent = '▶';
            }
        }

        function displayResult(data, filename) {
            globalStats = { totalNodes: 0, binaryFields: 0, recursiveDecodes: 0 };
            
            const treeHtml = renderJsonTree(data);
            
            const outputSection = document.getElementById('outputSection');
            outputSection.innerHTML = `
                <div class="success">
                    <strong>✅ Successfully decoded:</strong> ${filename}
                </div>
                
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-value">${globalStats.totalNodes}</div>
                        <div class="stat-label">Total Nodes</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${globalStats.binaryFields}</div>
                        <div class="stat-label">Binary Fields</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${globalStats.recursiveDecodes}</div>
                        <div class="stat-label">Recursive Decodes</div>
                    </div>
                </div>
                
                <div class="json-tree">
                    ${treeHtml}
                </div>
            `;
        }

        function displayError(message, filename = '') {
            const outputSection = document.getElementById('outputSection');
            outputSection.innerHTML = `
                <div class="error">
                    <strong>❌ Error decoding ${filename}:</strong><br>
                    ${message}
                </div>
                <div class="info">
                    <strong>Tips:</strong>
                    <ul style="margin-top: 10px; padding-left: 20px;">
                        <li>Make sure the file is properly CBOR-encoded</li>
                        <li>Check that the file isn't corrupted</li>
                        <li>Verify the file format and encoding</li>
                    </ul>
                </div>
            `;
        }

        function handleFile(file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    if (typeof CBOR === 'undefined' || !CBOR.decode) {
                        throw new Error('CBOR library not loaded. Please refresh the page and try again.');
                    }

                    const arrayBuffer = e.target.result;
                    let decoded;
                    
                    // Try different decode methods
                    if (typeof CBOR.decode === 'function') {
                        decoded = CBOR.decode(arrayBuffer);
                    } else {
                        throw new Error('CBOR.decode function not available');
                    }
                    
                    displayResult(decoded, file.name);
                } catch (error) {
                    console.error('CBOR decode error:', error);
                    displayError(error.message, file.name);
                }
            };
            
            reader.onerror = function() {
                displayError('Failed to read file', file.name);
            };
            
            reader.readAsArrayBuffer(file);
        }

        // File input handling
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                handleFile(file);
            }
        });

        // Drag and drop handling
        const dropZone = document.getElementById('dropZone');

        dropZone.addEventListener('dragover', function(e) {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', function(e) {
            e.preventDefault();
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', function(e) {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        dropZone.addEventListener('click', function() {
            document.getElementById('fileInput').click();
        });

        // Make toggleNode function globally available
        window.toggleNode = toggleNode;
    </script>
</body>
</html>
